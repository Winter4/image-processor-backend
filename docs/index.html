<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=devic  e-width, initial-scale=1.0">
    <title>Рекомендации по использованию WebAssembly</title>
    <link rel="stylesheet" href="reset.css">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/svg" href="./public/WebAssembly.svg" />
    <script src="script.js" defer></script>
</head>

<body>
    <div class="container">
        <nav>
            <a href="#header">Главная</a>
            <a href="#purity">Чистота</a>
            <a href="#memory">Память</a>
            <a href="#consumption">Потребление</a>
            <a href="#multithreading">Многопоточность</a>
            <a href="#expenses">Расходы</a>
            <a href="#cross-platform">Кроссплатформ</a>
            <a href="#patterns">Паттерны</a>
            <a href="#contacts">Контакты</a>
        </nav>
        <header id="header">
            <div class="shape orange"></div>
            <div class="shape gray"></div>
            <div class="header-content">
                <h1>
                    Рекомендации к работе<br />
                    «Исследование производительности WebAssembly при исполнении в среде Node.js»
                </h1>
                <img src="./public/WebAssembly.svg" alt="web-assembly" />
            </div>
        </header>
        <main>
            <section class="section-content" id="purity">
                <div class="section-content__headers">
                    <div class="section-content__logo">
                        <img src="./public/purity.png" alt="purity" />
                        <h3><b>Purity</b></h3>
                    </div>
                    <div class="section-content__logotext">
                        <p>
                            «Соблюдение концепции «чистой функции» <br /> — ключ к эффективности WebAssembly»
                        </p>
                    </div>
                </div>
                <div class="section-content__main">
                    <div class="shape blue"></div>
                    <h2>
                        Разработка WebAssembly-модулей в стиле «чистых функций» обеспечивает предсказуемое поведение,
                        облегчает отладку и даёт возможность компилятору оптимизировать код на этапе сборки. Это
                        особенно важно в многопоточной среде, где любые побочные эффекты могут привести к гонкам данных.
                        Чистые функции также проще кэшировать и параллелить, что делает их оптимальными для задач с
                        высокой вычислительной нагрузкой.
                    </h2>
                </div>
            </section>
            <section class="section-content" id="memory">
                <div class="section-content__headers reverse">
                    <div class="section-content__logo">
                        <img src="./public/memory-card.png" alt="memory" />
                        <h3>Memory</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape orangee"></div>
                        <p>
                            «Операции с памятью в WebAssembly очень эффективны и должны использоваться активно»
                        </p>
                    </div>
                </div>
                <div class="section-content__main reverse">
                    <h2>
                        Одно из ключевых преимуществ WebAssembly — быстрые и низкоуровневые операции с памятью. WASM
                        предоставляет доступ к линейной памяти через буферы, что позволяет работать с данными напрямую,
                        без абстракций, характерных для высокоуровневых языков. Такая модель обеспечивает высокую
                        скорость чтения и записи, минимальные накладные расходы и предсказуемое поведение. Это особенно
                        важно в задачах, где обрабатываются большие объёмы данных. Правильное использование памяти даёт
                        существенный прирост производительности, особенно в многопоточных конфигурациях.
                    </h2>
                </div>
            </section>
            <section class="section-content" id="consumption">
                <div class="section-content__headers">
                    <div class="section-content__logo">
                        <img src="./public/report.png" alt="report" />
                        <h3>Consumption</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape blue"></div>
                        <p>
                            «Рост потребления ресурсов — умеренный и допустимый»
                        </p>
                    </div>
                </div>
                <div class="section-content__main">
                    <h2>
                        Хотя WebAssembly потребляет больше оперативной памяти — на 30–65% в зависимости от конфигурации
                        — в абсолютных значениях это составляет всего 67 МБ против 40 МБ (для небольших данных) и 547 МБ
                        против 409 МБ (для больших). В контексте современных систем с 8+ ГБ ОЗУ эти значения находятся в
                        пределах разумного, особенно если учитывать получаемый прирост производительности в
                        многопоточном режиме.
                    </h2>
                </div>
            </section>
            <section class="section-content" id="multithreading">
                <div class="section-content__headers reverse">
                    <div class="section-content__logo">
                        <img src="./public/chain.png" alt="chain" />
                        <h3>Multithreading</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape orangee"></div>
                        <p>
                            «Многопоточность раскрывает потенциал WebAssembly»
                        </p>
                    </div>
                </div>
                <div class="section-content__main reverse">
                    <h2>
                        Тесты показывают, что однопоточный WebAssembly может проигрывать JavaScript из-за накладных
                        расходов и более медленной работы с памятью. Однако при увеличении числа доступных ядер ситуация
                        меняется радикально. При двух ядрах производительность увеличивается на 27–30%, а при четырёх —
                        ускорение достигает почти 60%. Это говорит о высокой масштабируемости решений на WebAssembly и
                        делает технологию особенно привлекательной для задач, легко раскладывающихся на независимые
                        потоки: анализ изображений, видеообработка, математическое моделирование и пр.
                    </h2>
                </div>
            </section>
            <section class="section-content" id="expenses">
                <div class="section-content__headers">
                    <div class="section-content__logo">
                        <img src="./public/calculator.png" alt="calc" />
                        <h3>Expenses</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape blue"></div>
                        <p>
                            «Накладные расходы оправданы при правильной архитектуре»
                        </p>
                    </div>
                </div>
                <div class="section-content__main">
                    <h2>
                        Даже несмотря на увеличение времени выполнения в однопоточном режиме, WebAssembly остаётся
                        полезным, если проектирование архитектуры изначально ориентировано на многопоточность. Задержки
                        на инициализацию воркеров, передачу данных и синхронизацию — естественная плата за параллелизм,
                        но они компенсируются при росте нагрузки или увеличении числа ядер. Важно учитывать это при
                        принятии решений об использовании технологии.
                    </h2>
                </div>
            </section>

            <section class="section-content" id="cross-platform">
                <div class="section-content__headers reverse">
                    <div class="section-content__logo">
                        <img src="./public/cross.png" alt="cross" />
                        <h3>Сross-platform</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape orangee"></div>
                        <p>
                            "WebAssembly хорошо подходит для кроссплатформенных вычислений»
                        </p>
                    </div>
                </div>
                <div class="section-content__main reverse">
                    <h2>
                        Модули WebAssembly могут запускаться как в браузере, так и в серверных или десктопных окружениях
                        с одинаковым поведением. Это позволяет использовать единый код как на клиенте, так и на сервере,
                        а также повторно использовать высокопроизводительные алгоритмы, написанные, например, на C или
                        Rust, без полной переписывания логики на JS.
                    </h2>
                </div>
            </section>

            <section class="section-content" id="patterns">
                <div class="section-content__headers">
                    <div class="section-content__logo">
                        <img src="./public/patterns.png" alt="patterns" />
                        <h3>Patterns</h3>
                    </div>
                    <div class="section-content__logotext">
                        <div class="shape blue"></div>
                        <p>
                            «WebAssembly особенно эффективен в задачах с предсказуемыми паттернами доступа к данным»
                        </p>
                    </div>
                </div>
                <div class="section-content__main">
                    <h2>
                        Если структура данных известна заранее и доступ осуществляется по фиксированным шаблонам
                        (например, линейная обработка массивов или матриц), WebAssembly может быть сильно оптимизирован
                        под эти сценарии компилятором, что даст значительный прирост скорости по сравнению с JS. Это
                        особенно полезно в численных расчётах, графике, машинном обучении и криптографии.
                    </h2>
                </div>
            </section>
        </main>
        <footer id="contacts">
            <div class="owner">
                <p>
                    Автор работы:
                </p>
            </div>
            <div class="contacts">
                <p>
                    Контакты:
                </p>
            </div>
            <div class="owner-name">
                Карпович Владимир
            </div>
            <div class="icons">
                <div class="footer__icons apper-block-height">
                    <a href="https://t.me/januarycoming">
                        <img src="./public/icon-telega.svg" alt="">
                    </a>
                    <a href="https://github.com/Winter4/webassembly-performance-research">
                        <img src="./public/icon-git.svg" alt="">
                    </a>
                    <a href="mywinter4@gmail.com">
                        <img src="./public/icon-gmail.svg" alt="">
                    </a>
                    <a href="https://vk.com/januarycoming">
                        <img src="./public/icon-vk.svg" alt="">
                    </a>
                </div>
        </footer>
    </div>
</body>

</html>